
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Standard Service Worker Lifecycle events.
// self.skipWaiting() and self.clients.claim() are often handled by the PWA plugin's config.
// If you set skipWaiting: true and clientsClaim: true in next.config.js for the PWA plugin,
// you might not need these explicit listeners, but they don't harm.
self.addEventListener('install', (event) => {
  console.log('[SW] Install event');
  // Ensure the new service worker activates immediately
  // self.skipWaiting(); // Let next-pwa handle this via config if set
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activate event');
  // Ensure the new service worker takes control of clients immediately
  // event.waitUntil(self.clients.claim()); // Let next-pwa handle this via config if set
});

cleanupOutdatedCaches();

// Define regex patterns for files to exclude from precaching
const problematicFilesRegexPatterns = [
  /\/app-build-manifest\.json(\?.*)?$/,
  /\/app-route-manifest\.json(\?.*)?$/,
  /\/_next\/static\/[a-zA-Z0-9_-]+\/_buildManifest\.js(\?.*)?$/,
  /\/_next\/static\/[a-zA-Z0-9_-]+\/_ssgManifest\.js(\?.*)?$/,
  /\.map$/,
  /middleware-manifest\.json(\?.*)?$/,
  /next-font-manifest\.(js|json)(\?.*)?$/,
];

// Filter the Workbox manifest
let manifestEntries = self.__WB_MANIFEST || [];

if (Array.isArray(manifestEntries)) {
  manifestEntries = manifestEntries.filter(entry => {
    const urlToCache = typeof entry === 'string' ? entry : entry.url;
    const shouldExclude = problematicFilesRegexPatterns.some(regex => regex.test(urlToCache));
    if (shouldExclude) {
      console.log('[SW] Excluding from precache manifest:', urlToCache);
    }
    return !shouldExclude;
  });
}

// Precache and route assets generated by the Next.js build using the filtered manifest
precacheAndRoute(manifestEntries);

// Push notification listener
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : { title: 'LeafWise', body: 'You have a new notification.' };
  event.waitUntil(
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: data.icon || '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: data.tag || 'default-tag',
      actions: data.actions || [],
      data: data.data || {}
    })
  );
});

// Notification click listener
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      if (clientList.length > 0) {
        let client = clientList[0];
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            client = clientList[i];
          }
        }
        return client.focus();
      }
      return clients.openWindow('/');
    })
  );
});

// Message listener for test notifications from client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SHOW_NOTIFICATION') {
    const payload = event.data.payload;
    self.registration.showNotification(payload.title, {
      body: payload.body,
      icon: payload.icon || '/icons/icon-192x192.png',
      badge: payload.badge || '/icons/badge-72x72.png', // Ensure this exists
      tag: payload.tag || 'test-notification',
    });
  }
});
